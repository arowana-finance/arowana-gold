/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
import type {
    BaseContract,
    BigNumberish,
    BytesLike,
    FunctionFragment,
    Result,
    Interface,
    EventFragment,
    AddressLike,
    ContractRunner,
    ContractMethod,
    Listener,
} from 'ethers';
import type {
    TypedContractEvent,
    TypedDeferredTopicFilter,
    TypedEventLog,
    TypedLogDescription,
    TypedListener,
    TypedContractMethod,
} from '../common.js';

export interface PriceUpdateAutomationInterface extends Interface {
    getFunction(
        nameOrSignature:
            | 'checkUpkeep'
            | 'functionsRouter'
            | 'getNextUpdateTime'
            | 'getTimeTillNextUpdate'
            | 'interval'
            | 'lastTimeStamp'
            | 'manualUpdate'
            | 'operators'
            | 'owner'
            | 'performUpkeep'
            | 'priceJobId'
            | 'priceOracle'
            | 'reserveJobId'
            | 'reserveOracle'
            | 'setJobIds'
            | 'setOperator'
            | 'setOracles',
    ): FunctionFragment;

    getEvent(
        nameOrSignatureOrTopic: 'IntervalUpdated' | 'PriceUpdateRequested' | 'ReserveUpdateRequested',
    ): EventFragment;

    encodeFunctionData(functionFragment: 'checkUpkeep', values: [BytesLike]): string;
    encodeFunctionData(functionFragment: 'functionsRouter', values?: undefined): string;
    encodeFunctionData(functionFragment: 'getNextUpdateTime', values?: undefined): string;
    encodeFunctionData(functionFragment: 'getTimeTillNextUpdate', values?: undefined): string;
    encodeFunctionData(functionFragment: 'interval', values?: undefined): string;
    encodeFunctionData(functionFragment: 'lastTimeStamp', values?: undefined): string;
    encodeFunctionData(functionFragment: 'manualUpdate', values?: undefined): string;
    encodeFunctionData(functionFragment: 'operators', values: [AddressLike]): string;
    encodeFunctionData(functionFragment: 'owner', values?: undefined): string;
    encodeFunctionData(functionFragment: 'performUpkeep', values: [BytesLike]): string;
    encodeFunctionData(functionFragment: 'priceJobId', values?: undefined): string;
    encodeFunctionData(functionFragment: 'priceOracle', values?: undefined): string;
    encodeFunctionData(functionFragment: 'reserveJobId', values?: undefined): string;
    encodeFunctionData(functionFragment: 'reserveOracle', values?: undefined): string;
    encodeFunctionData(functionFragment: 'setJobIds', values: [BytesLike, BytesLike]): string;
    encodeFunctionData(functionFragment: 'setOperator', values: [AddressLike, boolean]): string;
    encodeFunctionData(functionFragment: 'setOracles', values: [AddressLike, AddressLike]): string;

    decodeFunctionResult(functionFragment: 'checkUpkeep', data: BytesLike): Result;
    decodeFunctionResult(functionFragment: 'functionsRouter', data: BytesLike): Result;
    decodeFunctionResult(functionFragment: 'getNextUpdateTime', data: BytesLike): Result;
    decodeFunctionResult(functionFragment: 'getTimeTillNextUpdate', data: BytesLike): Result;
    decodeFunctionResult(functionFragment: 'interval', data: BytesLike): Result;
    decodeFunctionResult(functionFragment: 'lastTimeStamp', data: BytesLike): Result;
    decodeFunctionResult(functionFragment: 'manualUpdate', data: BytesLike): Result;
    decodeFunctionResult(functionFragment: 'operators', data: BytesLike): Result;
    decodeFunctionResult(functionFragment: 'owner', data: BytesLike): Result;
    decodeFunctionResult(functionFragment: 'performUpkeep', data: BytesLike): Result;
    decodeFunctionResult(functionFragment: 'priceJobId', data: BytesLike): Result;
    decodeFunctionResult(functionFragment: 'priceOracle', data: BytesLike): Result;
    decodeFunctionResult(functionFragment: 'reserveJobId', data: BytesLike): Result;
    decodeFunctionResult(functionFragment: 'reserveOracle', data: BytesLike): Result;
    decodeFunctionResult(functionFragment: 'setJobIds', data: BytesLike): Result;
    decodeFunctionResult(functionFragment: 'setOperator', data: BytesLike): Result;
    decodeFunctionResult(functionFragment: 'setOracles', data: BytesLike): Result;
}

export namespace IntervalUpdatedEvent {
    export type InputTuple = [newInterval: BigNumberish];
    export type OutputTuple = [newInterval: bigint];
    export interface OutputObject {
        newInterval: bigint;
    }
    export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
    export type Filter = TypedDeferredTopicFilter<Event>;
    export type Log = TypedEventLog<Event>;
    export type LogDescription = TypedLogDescription<Event>;
}

export namespace PriceUpdateRequestedEvent {
    export type InputTuple = [timestamp: BigNumberish];
    export type OutputTuple = [timestamp: bigint];
    export interface OutputObject {
        timestamp: bigint;
    }
    export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
    export type Filter = TypedDeferredTopicFilter<Event>;
    export type Log = TypedEventLog<Event>;
    export type LogDescription = TypedLogDescription<Event>;
}

export namespace ReserveUpdateRequestedEvent {
    export type InputTuple = [timestamp: BigNumberish];
    export type OutputTuple = [timestamp: bigint];
    export interface OutputObject {
        timestamp: bigint;
    }
    export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
    export type Filter = TypedDeferredTopicFilter<Event>;
    export type Log = TypedEventLog<Event>;
    export type LogDescription = TypedLogDescription<Event>;
}

export interface PriceUpdateAutomation extends BaseContract {
    connect(runner?: ContractRunner | null): PriceUpdateAutomation;
    waitForDeployment(): Promise<this>;

    interface: PriceUpdateAutomationInterface;

    queryFilter<TCEvent extends TypedContractEvent>(
        event: TCEvent,
        fromBlockOrBlockhash?: string | number | undefined,
        toBlock?: string | number | undefined,
    ): Promise<Array<TypedEventLog<TCEvent>>>;
    queryFilter<TCEvent extends TypedContractEvent>(
        filter: TypedDeferredTopicFilter<TCEvent>,
        fromBlockOrBlockhash?: string | number | undefined,
        toBlock?: string | number | undefined,
    ): Promise<Array<TypedEventLog<TCEvent>>>;

    on<TCEvent extends TypedContractEvent>(event: TCEvent, listener: TypedListener<TCEvent>): Promise<this>;
    on<TCEvent extends TypedContractEvent>(
        filter: TypedDeferredTopicFilter<TCEvent>,
        listener: TypedListener<TCEvent>,
    ): Promise<this>;

    once<TCEvent extends TypedContractEvent>(event: TCEvent, listener: TypedListener<TCEvent>): Promise<this>;
    once<TCEvent extends TypedContractEvent>(
        filter: TypedDeferredTopicFilter<TCEvent>,
        listener: TypedListener<TCEvent>,
    ): Promise<this>;

    listeners<TCEvent extends TypedContractEvent>(event: TCEvent): Promise<Array<TypedListener<TCEvent>>>;
    listeners(eventName?: string): Promise<Array<Listener>>;
    removeAllListeners<TCEvent extends TypedContractEvent>(event?: TCEvent): Promise<this>;

    checkUpkeep: TypedContractMethod<
        [arg0: BytesLike],
        [[boolean, string] & { upkeepNeeded: boolean }],
        'view'
    >;

    functionsRouter: TypedContractMethod<[], [string], 'view'>;

    getNextUpdateTime: TypedContractMethod<[], [bigint], 'view'>;

    getTimeTillNextUpdate: TypedContractMethod<[], [bigint], 'view'>;

    interval: TypedContractMethod<[], [bigint], 'view'>;

    lastTimeStamp: TypedContractMethod<[], [bigint], 'view'>;

    manualUpdate: TypedContractMethod<[], [void], 'nonpayable'>;

    operators: TypedContractMethod<[arg0: AddressLike], [boolean], 'view'>;

    owner: TypedContractMethod<[], [string], 'view'>;

    performUpkeep: TypedContractMethod<[arg0: BytesLike], [void], 'nonpayable'>;

    priceJobId: TypedContractMethod<[], [string], 'view'>;

    priceOracle: TypedContractMethod<[], [string], 'view'>;

    reserveJobId: TypedContractMethod<[], [string], 'view'>;

    reserveOracle: TypedContractMethod<[], [string], 'view'>;

    setJobIds: TypedContractMethod<[_priceJobId: BytesLike, _reserveJobId: BytesLike], [void], 'nonpayable'>;

    setOperator: TypedContractMethod<[operator: AddressLike, authorized: boolean], [void], 'nonpayable'>;

    setOracles: TypedContractMethod<
        [_priceOracle: AddressLike, _reserveOracle: AddressLike],
        [void],
        'nonpayable'
    >;

    getFunction<T extends ContractMethod = ContractMethod>(key: string | FunctionFragment): T;

    getFunction(
        nameOrSignature: 'checkUpkeep',
    ): TypedContractMethod<[arg0: BytesLike], [[boolean, string] & { upkeepNeeded: boolean }], 'view'>;
    getFunction(nameOrSignature: 'functionsRouter'): TypedContractMethod<[], [string], 'view'>;
    getFunction(nameOrSignature: 'getNextUpdateTime'): TypedContractMethod<[], [bigint], 'view'>;
    getFunction(nameOrSignature: 'getTimeTillNextUpdate'): TypedContractMethod<[], [bigint], 'view'>;
    getFunction(nameOrSignature: 'interval'): TypedContractMethod<[], [bigint], 'view'>;
    getFunction(nameOrSignature: 'lastTimeStamp'): TypedContractMethod<[], [bigint], 'view'>;
    getFunction(nameOrSignature: 'manualUpdate'): TypedContractMethod<[], [void], 'nonpayable'>;
    getFunction(nameOrSignature: 'operators'): TypedContractMethod<[arg0: AddressLike], [boolean], 'view'>;
    getFunction(nameOrSignature: 'owner'): TypedContractMethod<[], [string], 'view'>;
    getFunction(
        nameOrSignature: 'performUpkeep',
    ): TypedContractMethod<[arg0: BytesLike], [void], 'nonpayable'>;
    getFunction(nameOrSignature: 'priceJobId'): TypedContractMethod<[], [string], 'view'>;
    getFunction(nameOrSignature: 'priceOracle'): TypedContractMethod<[], [string], 'view'>;
    getFunction(nameOrSignature: 'reserveJobId'): TypedContractMethod<[], [string], 'view'>;
    getFunction(nameOrSignature: 'reserveOracle'): TypedContractMethod<[], [string], 'view'>;
    getFunction(
        nameOrSignature: 'setJobIds',
    ): TypedContractMethod<[_priceJobId: BytesLike, _reserveJobId: BytesLike], [void], 'nonpayable'>;
    getFunction(
        nameOrSignature: 'setOperator',
    ): TypedContractMethod<[operator: AddressLike, authorized: boolean], [void], 'nonpayable'>;
    getFunction(
        nameOrSignature: 'setOracles',
    ): TypedContractMethod<[_priceOracle: AddressLike, _reserveOracle: AddressLike], [void], 'nonpayable'>;

    getEvent(
        key: 'IntervalUpdated',
    ): TypedContractEvent<
        IntervalUpdatedEvent.InputTuple,
        IntervalUpdatedEvent.OutputTuple,
        IntervalUpdatedEvent.OutputObject
    >;
    getEvent(
        key: 'PriceUpdateRequested',
    ): TypedContractEvent<
        PriceUpdateRequestedEvent.InputTuple,
        PriceUpdateRequestedEvent.OutputTuple,
        PriceUpdateRequestedEvent.OutputObject
    >;
    getEvent(
        key: 'ReserveUpdateRequested',
    ): TypedContractEvent<
        ReserveUpdateRequestedEvent.InputTuple,
        ReserveUpdateRequestedEvent.OutputTuple,
        ReserveUpdateRequestedEvent.OutputObject
    >;

    filters: {
        'IntervalUpdated(uint256)': TypedContractEvent<
            IntervalUpdatedEvent.InputTuple,
            IntervalUpdatedEvent.OutputTuple,
            IntervalUpdatedEvent.OutputObject
        >;
        IntervalUpdated: TypedContractEvent<
            IntervalUpdatedEvent.InputTuple,
            IntervalUpdatedEvent.OutputTuple,
            IntervalUpdatedEvent.OutputObject
        >;

        'PriceUpdateRequested(uint256)': TypedContractEvent<
            PriceUpdateRequestedEvent.InputTuple,
            PriceUpdateRequestedEvent.OutputTuple,
            PriceUpdateRequestedEvent.OutputObject
        >;
        PriceUpdateRequested: TypedContractEvent<
            PriceUpdateRequestedEvent.InputTuple,
            PriceUpdateRequestedEvent.OutputTuple,
            PriceUpdateRequestedEvent.OutputObject
        >;

        'ReserveUpdateRequested(uint256)': TypedContractEvent<
            ReserveUpdateRequestedEvent.InputTuple,
            ReserveUpdateRequestedEvent.OutputTuple,
            ReserveUpdateRequestedEvent.OutputObject
        >;
        ReserveUpdateRequested: TypedContractEvent<
            ReserveUpdateRequestedEvent.InputTuple,
            ReserveUpdateRequestedEvent.OutputTuple,
            ReserveUpdateRequestedEvent.OutputObject
        >;
    };
}
